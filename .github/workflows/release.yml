name: Automated Release

on:
  push:
    branches:
      - main
    # Skip automated releases for version tags and dependabot
    paths-ignore:
      - '.github/workflows/**'
      - '**/package-lock.json'
      - '**/yarn.lock'
  # Allow manual trigger for testing
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type (auto, patch, minor, major)'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major

permissions:
  contents: write
  pull-requests: read

jobs:
  determine-version:
    runs-on: ubuntu-latest
    outputs:
      version_type: ${{ steps.version-determination.outputs.version_type }}
      new_version: ${{ steps.version-determination.outputs.new_version }}
      should_release: ${{ steps.version-determination.outputs.should_release }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for version analysis

    - name: Determine version bump type
      id: version-determination
      run: |
        # Get current version
        CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        CURRENT_VERSION=${CURRENT_VERSION#v}
        echo "Current version: v${CURRENT_VERSION}"

        # Get the version bump type from input or auto-determine
        if [ "${{ github.event.inputs.version_type }}" != "" ] && [ "${{ github.event.inputs.version_type }}" != "auto" ]; then
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          echo "Using manual version type: $VERSION_TYPE"
        else
          # Auto-determine version type based on recent commits
          echo "Auto-determining version type..."

          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            COMMITS=$(git log --oneline ${LAST_TAG}..HEAD)
          else
            COMMITS=$(git log --oneline --max-count=20)
          fi

          # Analyze commits for version bump determination
          MAJOR_KEYWORDS="breaking|major|breaking change|api change|remove|delete|drop"
          MINOR_KEYWORDS="feat|feature|add|new|implement|create|enhance|improve"
          PATCH_KEYWORDS="fix|bug|patch|hotfix|security|lint|style|refactor|docs|chore"

          MAJOR_COUNT=$(echo "$COMMITS" | grep -i -c -E "$MAJOR_KEYWORDS" || true)
          MINOR_COUNT=$(echo "$COMMITS" | grep -i -c -E "$MINOR_KEYWORDS" || true)
          PATCH_COUNT=$(echo "$COMMITS" | grep -i -c -E "$PATCH_KEYWORDS" || true)

          echo "Analysis results:"
          echo "  Major indicators: $MAJOR_COUNT"
          echo "  Minor indicators: $MINOR_COUNT"
          echo "  Patch indicators: $PATCH_COUNT"

          # Determine version type based on analysis
          if [ "$MAJOR_COUNT" -gt 0 ]; then
            VERSION_TYPE="major"
          elif [ "$MINOR_COUNT" -gt 0 ]; then
            VERSION_TYPE="minor"
          else
            VERSION_TYPE="patch"
          fi

          echo "Auto-determined version type: $VERSION_TYPE"
        fi

        # Parse current version
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

        # Increment version
        case $VERSION_TYPE in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
        esac

        NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
        NEW_TAG="v${NEW_VERSION}"

        echo "New version: $NEW_TAG"
        echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT

        # Check if we should create a release (skip for automated pushes from this workflow)
        if [[ "${{ github.event.head_commit.message }}" == *"ðŸ¤– Automated release"* ]]; then
          echo "should_release=false" >> $GITHUB_OUTPUT
          echo "Skipping release creation (automated commit)"
        else
          echo "should_release=true" >> $GITHUB_OUTPUT
        fi

  release:
    needs: determine-version
    if: needs.determine-version.outputs.should_release == 'true'
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run quality checks
      run: |
        echo "ðŸ” Running final quality checks for release..."
        npm run lint

        ERROR_COUNT=$(npm run lint 2>&1 | grep -c "error")
        if [ "$ERROR_COUNT" -gt 0 ]; then
          echo "âŒ Cannot release: Found $ERROR_COUNT critical errors"
          exit 1
        fi

        echo "âœ… All quality checks passed"

    - name: Update package.json version
      run: |
        NEW_VERSION="${{ needs.determine-version.outputs.new_version }}"
        echo "Updating package.json to version $NEW_VERSION"
        npm version $NEW_VERSION --no-git-tag-version

    - name: Create and push version commit
      run: |
        NEW_TAG="${{ needs.determine-version.outputs.new_tag }}"
        VERSION_TYPE="${{ needs.determine-version.outputs.version_type }}"

        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

        git add package.json
        git commit -m "ðŸ¤– Automated release: Bump version to $NEW_TAG" || echo "No changes to commit"

        git tag -a "$NEW_TAG" -m "Release $NEW_TAG

        Automated release created on $(date -u)
        Version type: $VERSION_TYPE
        Generated by GitHub Actions"

        git push origin main
        git push origin "$NEW_TAG"

    - name: Generate release notes
      id: release-notes
      run: |
        NEW_TAG="${{ needs.determine-version.outputs.new_tag }}"
        VERSION_TYPE="${{ needs.determine-version.outputs.version_type }}"
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")

        if [ -n "$PREVIOUS_TAG" ]; then
          CHANGES=$(git log --pretty=format:"- %s" ${PREVIOUS_TAG}..HEAD)
        else
          CHANGES=$(git log --pretty=format:"- %s" --max-count=20)
        fi

        echo "## ðŸš€ Release ${NEW_TAG}
        **Date:** $(date -u)
        **Type:** ${VERSION_TYPE^} release

        ### Changes
        $CHANGES

        ### Quality Metrics
        - **Linting Status:** âœ… Passed
        - **Critical Errors:** 0
        - **Total Issues:** $(npm run lint 2>&1 | grep -o "[0-9]* problems" | head -1)

        ### Deployment
        Ready for production deployment âœ¨

        _This release was automatically created by GitHub Actions_" > release_notes.md

        echo "release_notes<<EOF" >> $GITHUB_OUTPUT
        cat release_notes.md >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ needs.determine-version.outputs.new_tag }}
        release_name: Release ${{ needs.determine-version.outputs.new_tag }}
        body: ${{ steps.release-notes.outputs.release_notes }}
        draft: false
        prerelease: false

    - name: Notify deployment team
      run: |
        NEW_TAG="${{ needs.determine-version.outputs.new_tag }}"
        echo "ðŸ“¢ Release ${NEW_TAG} is ready for deployment!"
        echo "Release notes have been generated and attached to the GitHub release."
        echo "ðŸ”— Release URL: https://github.com/bixoryai/bixingai-web/releases/tag/${NEW_TAG}"